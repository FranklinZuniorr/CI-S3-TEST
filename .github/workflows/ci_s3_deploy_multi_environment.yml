name: Build the application, upload to Amazon S3, and invalidate CloudFront cache.

on:
  workflow_call:
    inputs:
      project_build_envs:
        required: false
        type: string
      environment_type:
        required: true
        type: string
      node_version: 
        required: false
        type: number
        default: 22
      has_semantic_release:
        required: false
        type: boolean
        default: true
      is_preview:
        required: false
        type: boolean
        default: false
    secrets:
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true
      AWS_REGION:
        required: true
      S3_BUCKET_NAME:
        required: true
      CLOUDFRONT_DISTRIBUTION_ID:
        required: false
      WF_GITHUB_TOKEN:
        required: false

env:
  APP_PREFIX: ${{ inputs.is_preview && format('preview-pr-{0}', github.event.pull_request.number) || '' }}
  IS_PREVIEW: ${{ inputs.is_preview }}
  VITE_BROWSER_ROUTER_BASENAME: ${{ inputs.is_preview && format('/preview-pr-{0}', github.event.pull_request.number) || '/' }}
  REACT_APP_BROWSER_ROUTER_BASENAME: ${{ inputs.is_preview && format('/preview-pr-{0}', github.event.pull_request.number) || '/' }}

jobs:
  build_and_upload_to_s3:
    name: Deploy build to S3
    runs-on: ubuntu-latest
    environment:
      name: ${{ inputs.environment_type }}

    steps:
      - name: Validate environment_type input
        run: |
          case "${{ inputs.environment_type }}" in
            stage|prod)
              echo "âœ… environment_type is valid: ${{ inputs.environment_type }}"
              ;;
            *)
              echo "âŒ Invalid environment_type: ${{ inputs.environment_type }}"
              exit 1
              ;;
          esac

      - name: Checkout
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ inputs.node_version }}
          cache: 'yarn'

      - name: Cache node_modules
        uses: actions/cache@v3
        with:
          path: |
            **/node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install Dependencies
        run: yarn install --frozen-lockfile

      - name: Commit message lint
        if: inputs.environment_type == 'test'
        uses: wagoid/commitlint-github-action@v6
        with:
          token: ${{ secrets.WF_GITHUB_TOKEN }}

      - name: Typescript check
        if: inputs.environment_type == 'test' 
        run: yarn tsc --build

      - name: Test coverage
        if: inputs.environment_type == 'test'
        run: yarn test:ci

      - name: Upload coverage report
        if: inputs.environment_type == 'test'
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: coverage

      - name: Comment coverage report
        if: github.event_name == 'pull_request' && inputs.environment_type == 'test'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.WF_GITHUB_TOKEN }}
          script: |
            const prNumber = context.payload.pull_request.number;
            const runId = context.runId;
            const { owner, repo } = context.repo;
            const artifactUrl = `https://github.com/${owner}/${repo}/actions/runs/${runId}`;

            await github.rest.issues.createComment({
              issue_number: prNumber,
              owner,
              repo,
              body: `ðŸ“Š Coverage report uploaded as an artifact. [Click here to view it](${artifactUrl})\n
              ![Coverage GIF](https://i.giphy.com/XIqCQx02E1U9W.webp)`
            });

      - name: Create .env by "project_build_envs" input
        run: |
          printf "%s" "$PROJECT_ENVS" > .env
          echo "âœ… File .env created from input"
        env:
          PROJECT_ENVS: ${{ inputs.project_build_envs }}
        
      - name: Build project
        run: yarn build
        
      - name: Upload to S3
        run: |
          aws s3 sync ./build "$S3_BUCKET_NAME" --delete
      
          aws s3 cp ./build/ "$S3_BUCKET_NAME" --recursive \
            --exclude "index.html" \
            --cache-control "max-age=86400, public" \
            --metadata-directive REPLACE
      
          aws s3 cp ./build/index.html "$S3_BUCKET_NAME/index.html" \
            --cache-control "no-cache, no-store, must-revalidate" \
            --metadata-directive REPLACE
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          S3_BUCKET_NAME: ${{ format('s3://{0}/{1}', secrets.S3_BUCKET_NAME, env.APP_PREFIX) }}

  publish_application_and_invalidate_cache:
    needs: build_and_upload_to_s3
    name: Publish application and invalidate cache
    runs-on: ubuntu-latest
    environment:
      name: ${{ inputs.environment_type }}

    steps:
      - name: Ensure CloudFront Function for preview
        if: ${{ inputs.is_preview }}
        run: |
          FUNCTION_NAME="preview-pr-function"
          FUNCTION_CODE_FILE="cloudfront-functions/preview-pr.js"
          DIST_ID="${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}"

          # --- Cria o arquivo da funÃ§Ã£o localmente ---
          mkdir -p cloudfront-functions
          cat << 'EOF' > $FUNCTION_CODE_FILE
          function handler(event) {
              var request = event.request;
              var uri = request.uri;

              // Captura paths como /preview-pr-45 ou /preview-pr-45/something
              var match = uri.match(/^\/preview-pr-(\d+)(\/.*)?$/);

              if (match) {
                  var prNumber = match[1];
                  request.uri = "/preview-pr-" + prNumber + "/index.html";
              }

              return request;
          }
          EOF

          # --- ObtÃ©m o status da funÃ§Ã£o, se ela existir ---
          echo "Verificando se a funÃ§Ã£o '$FUNCTION_NAME' jÃ¡ existe..."
          FUNCTION_DATA=$(aws cloudfront list-functions --query "FunctionList.Items[?Name=='$FUNCTION_NAME']")
          FUNCTION_EXISTS=$(echo "$FUNCTION_DATA" | jq -e 'any') || true

          if [ "$FUNCTION_EXISTS" == "false" ]; then
            echo "FunÃ§Ã£o nÃ£o existe. Criando..."
            aws cloudfront create-function \
              --name $FUNCTION_NAME \
              --function-config '{"Runtime":"cloudfront-js-1.0","Comment":"Preview PR function"}' \
              --function-code fileb://$FUNCTION_CODE_FILE
          else
            echo "FunÃ§Ã£o existe. NÃ£o Ã© necessÃ¡rio criar. O script continuarÃ¡ para a prÃ³xima etapa."
          fi

          # --- Publica a funÃ§Ã£o e espera ela ficar LIVE ---
          echo "Publicando a funÃ§Ã£o..."
          aws cloudfront publish-function --name $FUNCTION_NAME

          # Aguarda a funÃ§Ã£o se tornar LIVE com um limite de 10 tentativas
          for i in {1..10}; do
              echo "Aguardando funÃ§Ã£o ficar LIVE (Tentativa $i de 10)..."
              sleep 3
              STAGE=$(aws cloudfront describe-function --name $FUNCTION_NAME --query "Function.FunctionMetadata.Stage" --output text)
              if [ "$STAGE" == "LIVE" ]; then
                  echo "âœ… FunÃ§Ã£o estÃ¡ LIVE!"
                  break
              fi
              if [ "$i" -eq 10 ]; then
                  echo "âŒ Tempo esgotado para a funÃ§Ã£o ficar LIVE."
                  exit 1
              fi
          done

          # --- Atualiza a distribuiÃ§Ã£o ---
          echo "Atualizando a distribuiÃ§Ã£o CloudFront..."
          FUNCTION_ARN=$(aws cloudfront list-functions \
            --query "FunctionList.Items[?Name=='$FUNCTION_NAME'].FunctionMetadata.FunctionARN" \
            --output text)

          aws cloudfront get-distribution-config --id "$DIST_ID" --output json > dist.json
          ETAG=$(jq -r '.ETag' dist.json)
          CONFIG=$(jq '.DistributionConfig' dist.json)

          CONFIG=$(echo "$CONFIG" | jq '
            .CacheBehaviors.Items //= [] |
            .CacheBehaviors.Quantity //= 0
          ')

          EXISTS_BEHAVIOR=$(echo "$CONFIG" | jq -r '.CacheBehaviors.Items[]?.PathPattern | select(.=="/preview-pr*")')

          if [ -z "$EXISTS_BEHAVIOR" ]; then
            echo "Adicionando behavior /preview-pr*..."
            UPDATED_CONFIG=$(echo "$CONFIG" | jq --arg FUNC_ARN "$FUNCTION_ARN" '
              .CacheBehaviors.Items += [{
                "PathPattern": "/preview-pr*",
                "TargetOriginId": .Origins.Items[0].Id,
                "ViewerProtocolPolicy": "redirect-to-https",
                "FunctionAssociations": {
                  "Quantity": 1,
                  "Items": [{
                    "FunctionARN": $FUNC_ARN,
                    "EventType": "viewer-request"
                  }]
                }
              }] |
              .CacheBehaviors.Quantity = (.CacheBehaviors.Items | length)
            ')
          else
            echo "Behavior /preview-pr* existe. Atualizando FunctionARN..."
            UPDATED_CONFIG=$(echo "$CONFIG" | jq --arg FUNC_ARN "$FUNCTION_ARN" '
              .CacheBehaviors.Items |= map(
                if .PathPattern == "/preview-pr*" then
                  .FunctionAssociations.Items[0].FunctionARN = $FUNC_ARN
                  | .
                else
                  .
                end
              )
            ')
          fi

          echo "$UPDATED_CONFIG" > dist-updated.json

          aws cloudfront update-distribution \
            --id "$DIST_ID" \
            --distribution-config file://dist-updated.json \
            --if-match "$ETAG"
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          CLOUDFRONT_DISTRIBUTION_ID: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}
  
      - name: Invalidate CloudFront cache (index.html ONLY)
        if: ${{ steps.check_full_invalidation.outputs.has_full_invalidation == 'yes' }}
        run: |
          PREFIX="/${APP_PREFIX#"/"}"
          aws cloudfront create-invalidation \
            --distribution-id $CLOUDFRONT_DISTRIBUTION_ID --paths "$PREFIX/index.html"
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          CLOUDFRONT_DISTRIBUTION_ID: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}
          APP_PREFIX: ${{ env.APP_PREFIX }}
        
      - name: Invalidate CloudFront cache (ALL)
        if: ${{ steps.check_full_invalidation.outputs.has_full_invalidation == 'no' }}
        run: |
          aws cloudfront create-invalidation \
            --distribution-id $CLOUDFRONT_DISTRIBUTION_ID --paths "/*"
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          CLOUDFRONT_DISTRIBUTION_ID: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}
        
      - name: Get CloudFront Domain Name and Alternate Name
        id: get_cf_domain
        run: |
          DOMAIN_NAME=$(aws cloudfront get-distribution --id $CLOUDFRONT_DISTRIBUTION_ID \
            --query 'Distribution.DomainName' --output text)
      
          ALTERNATE_NAME=$(aws cloudfront get-distribution --id $CLOUDFRONT_DISTRIBUTION_ID \
            --query 'Distribution.DistributionConfig.Aliases.Items[0]' --output text)
      
          echo "Domain name is: $DOMAIN_NAME"
          echo "Alternate domain (CNAME) is: $ALTERNATE_NAME"
      
          echo "domain_name=$DOMAIN_NAME" >> "$GITHUB_OUTPUT"
          echo "alternate_name=$ALTERNATE_NAME" >> "$GITHUB_OUTPUT"
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          CLOUDFRONT_DISTRIBUTION_ID: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}

      - name: Output release URL
        if: ${{ (steps.get_cf_domain.outputs.alternate_name != 'None' || steps.get_cf_domain.outputs.domain_name != '') && !inputs.is_preview }}
        run: |
          DOMAIN_NAME="${DOMAIN_NAME}"
          ALTERNATE_DOMAIN="${ALTERNATE_DOMAIN}"
      
          if [[ -n "$ALTERNATE_DOMAIN" && "$ALTERNATE_DOMAIN" != "None" ]]; then
            PREVIEW_URL="https://${ALTERNATE_DOMAIN}"
          else
            PREVIEW_URL="https://${DOMAIN_NAME}"
          fi
      
          echo "### ðŸŒ Release disponÃ­vel" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "ðŸ”— $PREVIEW_URL" >> "$GITHUB_STEP_SUMMARY"
        env:
          DOMAIN_NAME: ${{ steps.get_cf_domain.outputs.domain_name }}
          ALTERNATE_DOMAIN: ${{ steps.get_cf_domain.outputs.alternate_name }}

      - name: Output preview URL
        uses: actions/github-script@v6
        if: ${{ (steps.get_cf_domain.outputs.alternate_name != 'None' || steps.get_cf_domain.outputs.domain_name != '') && github.event_name == 'pull_request' && inputs.is_preview }}
        env:
          APP_PREFIX: ${{ env.APP_PREFIX }}
          DOMAIN_NAME: ${{ steps.get_cf_domain.outputs.domain_name }}
          ALTERNATE_DOMAIN: ${{ steps.get_cf_domain.outputs.alternate_name }}
        with:
          github-token: ${{ secrets.WF_GITHUB_TOKEN }}
          script: |
            const prNumber = context.payload.pull_request.number;
            const previewPrefix = process.env.APP_PREFIX;
            const domainName = process.env.DOMAIN_NAME;
            const alternateDomain = process.env.ALTERNATE_DOMAIN;

            const selectedDomain = alternateDomain !== "None" && domainName !== "None" ? `https://${alternateDomain}` : `https://${domainName}`;
      
            const previewUrl = `${selectedDomain}/${previewPrefix}`;
      
            await github.rest.issues.createComment({
              issue_number: prNumber,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `ðŸš€ Preview disponÃ­vel: [${previewUrl}](${previewUrl})\n
              ![Coverage GIF](https://media1.giphy.com/media/v1.Y2lkPTc5MGI3NjExZThtYmVtZThra2loajhjbmIzM2ZnNHAxZHQ4aHowcHkzZnV2Nzl5OCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/ukZvSoWXXb3YKNHIsw/giphy.gif)`
            });
      
      # - name: Semantic release
      #   if: ${{ inputs.has_semantic_release == true }}
      #   env:
      #     GITHUB_TOKEN: ${{ secrets.WF_GITHUB_TOKEN }}
      #   run: yarn release
      